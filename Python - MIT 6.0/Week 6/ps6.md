### Problem 1-1

The ONLY thing we are interested in when designing programs is that it returns the correct answer.

False correct

### Problem 1-2

When determining asymptotic complexity, we discard all terms except for the one with the largest growth rate.

True correct

### Problem 1-3

Bisection search is an example of linear time complexity

False correct

### Problem 1-4

For large values of `n`, an algorithm that takes `20000n^2` steps has better time complexity (takes less time) than one that takes `0.001n^5` steps

True correct

### Problem 2-1

Indirection, as talked about in lecture, means you have to traverse the list more than once.

False correct

### Problem 2-2

The complexity of binary search on a sorted list of *n* items is O(logn).

True correct

### Problem 2-3

The worst case time complexity for selection sort is O(n2).

True correct

### Problem 2-4

The base case for the recursive version of merge sort from lecture is checking ONLY for the list being empty.

False correct

